__init__.py — указывает интерпретатору Python, что текущий каталог — это пакет (например, его можно импортировать
; если нет __init__.py — импорт может сработать некорректно).
admin.py — здесь можно настроить отображение админ-зоны приложения.
apps.py — настройки конфигурации приложения. 
models.py — здесь разработчик описывает устройство базы данных приложения. 
migrations/ — тут хранится история изменений в базе данных. 
tests.py — файл для тестов приложения. 
views.py — тут хранятся обработчики запросов (функции или классы, получающие запрос и генерирующие ответ). 

apps.py - нём описываются настройки приложения

Начиная с версии Django 2 для связи URL и обработчика применяется функция path(). Она принимает обязательные параметры path('route', view):
route — шаблон обрабатываемого адреса, образец, с которым сравнивается полученный запрос;
view — функция-обработчик: если запрошенный URL совпадает с route, вызов будет перенаправлен в указанную view-функцию (view-функции в Django хранят в файле views.py).

Во view функции пишем словарь с передаваемыми значениями
В .html можем обратиться к этому словарю:
Если просто ходит вызвать то, что написали: Ключ указывают в двойных фигурных скобках {{ ... }}
<!DOCTYPE html>
<html>
  <head>
    <title>{{ title }}</title>
  </head>
  <body>
    <h1>{{ text }}</h1>
  </body>
</html>


{{ var_dict.key }} — обращение к ключу вложенного словаря
{{ var_instance.attribute }} — обращение к свойству или методу класса
{{ var_list.0 }} — обращение к элементу списка

Ветвление
Полученные данные можно обрабатывать прямо в шаблоне. Тег ветвления {% if %} очень похож на оператор if/elif/else в языке Python. Обратите внимание: у тега {% if %} обязательно должен быть закрывающий тег {% endif %}:
{% if text == 'Главная страница' %}
    Вы на главной странице.
{% elif text == 'Вложенная страница' %}
    Вы в одном клике от главной страницы!
{% else %}
    Мы понятия не имеем, где вы!
{% endif %} 
Тот или иной вариант текста будет выведен в зависимости от того, какое значение передано в словаре context под ключом text.

Циклы
Пример цикла:
<!DOCTYPE html>
<html>
  <body> 
    {% for char in text %}
      {% if forloop.first %}
        <p>Начало цикла</p>
      {% endif %}
      <p>{{ char }}</p>
      {# forloop хранит счётчик цикла и может определять разные состояния счётчика #}
      {% if forloop.last %}
        <p>Конец цикла</p>
      {% endif %}
    {% empty %}
      <p>Если цикл пуст</p>
    {% endfor %}    
  </body>
</html>

В цикле применена переменная forloop — это счётчик итераций цикла, у которого есть несколько полезных атрибутов, 
которые пригодятся в работе с циклом:
forloop.counter — номер текущей итерации цикла (начинает отсчёт с 1).
forloop.counter0 — номер текущей итерации цикла «по-программистски» (начинает отсчёт с 0).
forloop.revcounter — количество итераций, оставшихся до конца цикла (начинает отсчёт с 1).
forloop.revcounter0 — количество итераций, оставшихся до конца цикла (начинает отсчёт с 0).
forloop.first — возвращает True, если это первая итерация.
forloop.last — возвращает True, если это последняя итерация.
Дополнительно в циклах шаблонов применяют необязательный тег {% empty %}. Его ставят перед закрывающим тегом 
{% endfor %}; после тега {% empty %} размещают содержимое, которое будет показано, если цикл пуст.


Получить данные из БД 

Вот ещё несколько примеров, как можно получить данные из базы:
Post.objects.all() — получить все записи модели Post.
Post.objects.get(id=1) — получить запись модели Post, у которой значение поля id равно 1. Поскольку поле id 
— это первичный ключ, а Django автоматически создаёт у модели свойство pk, то другой вариант этого же запроса 
будет таким: Post.objects.get(pk=1).
Post.objects.filter(pub_date__year=1854) — запрос вернёт объекты, у которых значение года в поле pub_date равно 
1854. Обратите внимание на синтаксис фильтрации: двойное нижнее подчёркивание между названиями поля и фильтра.
 Подробнее о функции filter() — в документации.
Post.objects.filter(text__startswith='Писать не хочется') — пример фильтра по текстовому полю, он вернёт записи,
 начинающиеся с указанной в фильтре строки.

Правила оформления
HTML-шаблоны
Отступ перед вложенными элементами — два пробела:
<ul>
  <li>элемент списка</li>
</ul> 
Одиночные теги типа <br> не следует закрывать (не надо так: <br/>).
Названия атрибутов пишутся в двойных кавычках:
class="attr-not-single-quotes"
Имена классов и идентификаторов пишутся строчными буквами и разделяются дефисом -. Например: my-class-not-underscore
Если описание тега длиннее 79 символов — нужен перенос строки. Новая строка отбивается двумя пробелами от начала строки родительского тега.
<div
  id="my-id"
  class="my-class-long-name">
  <p>
    Lorem Ipsum Dolor Sit....
  </p>
</div> 
Если необходимо избежать лишнего пробела в текстовой части, возможно и такое написание:
<a
  id="my-id"
  class="my-class-long-name"
>Lorem Ipsum Dolor Sit....</a> 
Django-шаблоны
Код шаблонов оформляется согласно Coding style Django.
Вокруг переменных ставится одиночный пробел:
{{ foo }} 
Не ставятся пробелы между фильтрами:
{{ name|lower }} 
Теги Django по значимости идентичны HTML-тегам. Отступ перед вложенными элементами — два пробела:
{% extends 'base.html' %}
{% load static %}
{% block css %}
{% endblock %}

<title>
  {% block title %}
    Надпись сверху
  {% endblock %}
</title>

{% block content %}
  <main>
    {% for post in object_list %}    
      <div class="single-post"> 
        <p>Текст поста</p>
      </div>
    {% endfor %}
  </main>
{% endblock %} 
